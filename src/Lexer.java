/* The following code was generated by JFlex 1.9.1 */

import java_cup.runtime.*;

/**
 * This class is a scanner generated by JFlex
 */
public class Lexer implements java_cup.runtime.Scanner {

  private java.io.Reader zzReader;
  private int yyline;
  private int yycolumn;
  private StringBuilder buffer;
  private int currentPos;
  private boolean zzAtEOF;

  private static final int MAX_INTEGER_VALUE = 32767;
  private static final int MIN_INTEGER_VALUE = -32767;

  private Symbol symbol(int type)               {return new Symbol(type, yyline, yycolumn);}
  private Symbol symbol(int type, Object value) {return new Symbol(type, yyline, yycolumn, value);}

  public int getLine() { return yyline + 1; }
  public int getColumn() { return yycolumn + 1; }
  public int getTokenStartPosition() { return yycolumn + 1; }

  public Lexer(java.io.Reader in) {
    this.zzReader = in;
    this.yyline = 0;
    this.yycolumn = 0;
    this.buffer = new StringBuilder();
    this.currentPos = 0;
    this.zzAtEOF = false;
  }

  private int read() throws java.io.IOException {
    if (currentPos < buffer.length()) {
      return buffer.charAt(currentPos++);
    }

    int c = zzReader.read();
    if (c == -1) {
      zzAtEOF = true;
      return -1;
    }

    buffer.append((char)c);
    currentPos++;
    return c;
  }

  private void unread() {
    if (currentPos > 0) {
      currentPos--;
    }
  }

  private int peek() throws java.io.IOException {
    if (currentPos < buffer.length()) {
      return buffer.charAt(currentPos);
    }

    int c = zzReader.read();
    if (c == -1) {
      return -1;
    }

    buffer.append((char)c);
    return c;
  }

  public Symbol next_token() throws java.io.IOException {
    while (true) {
      if (zzAtEOF) {
        return symbol(TokenNames.EOF);
      }

      int tokenStartColumn = yycolumn;
      int c = read();

      if (c == -1) {
        return symbol(TokenNames.EOF);
      }

      char ch = (char)c;

      // Skip whitespace
      if (ch == ' ' || ch == '\t') {
        yycolumn++;
        continue;
      }

      if (ch == '\n') {
        yyline++;
        yycolumn = 0;
        continue;
      }

      if (ch == '\r') {
        int next = peek();
        if (next == '\n') {
          read(); // consume \n
        }
        yyline++;
        yycolumn = 0;
        continue;
      }

      // Handle comments
      if (ch == '/') {
        int next = peek();
        if (next == '/') {
          // Single line comment
          read(); // consume second /
          yycolumn += 2;
          while (true) {
            int commentChar = read();
            if (commentChar == -1 || commentChar == '\n' || commentChar == '\r') {
              if (commentChar == '\n') {
                yyline++;
                yycolumn = 0;
              } else if (commentChar == '\r') {
                int afterCr = peek();
                if (afterCr == '\n') {
                  read();
                }
                yyline++;
                yycolumn = 0;
              }
              break;
            }
            yycolumn++;
          }
          continue;
        } else if (next == '*') {
          // Multi-line comment
          read(); // consume *
          yycolumn += 2;
          while (true) {
            int commentChar = read();
            if (commentChar == -1) {
              throw new Error("Unterminated comment");
            }
            if (commentChar == '\n') {
              yyline++;
              yycolumn = 0;
            } else if (commentChar == '\r') {
              int afterCr = peek();
              if (afterCr == '\n') {
                read();
              }
              yyline++;
              yycolumn = 0;
            } else {
              yycolumn++;
              if (commentChar == '*') {
                int afterStar = peek();
                if (afterStar == '/') {
                  read();
                  yycolumn++;
                  break;
                }
              }
            }
          }
          continue;
        }
      }

      // Keywords and identifiers
      if (Character.isLetter(ch)) {
        StringBuilder sb = new StringBuilder();
        sb.append(ch);

        while (true) {
          int next = peek();
          if (next == -1 || !(Character.isLetterOrDigit((char)next))) {
            break;
          }
          sb.append((char)read());
        }

        String text = sb.toString();
        yycolumn = tokenStartColumn + text.length();

        switch (text) {
          case "if": return symbol(TokenNames.IF);
          case "int": return symbol(TokenNames.TYPE_INT);
          case "string": return symbol(TokenNames.TYPE_STRING);
          case "void": return symbol(TokenNames.TYPE_VOID);
          case "array": return symbol(TokenNames.ARRAY);
          case "class": return symbol(TokenNames.CLASS);
          case "return": return symbol(TokenNames.RETURN);
          case "while": return symbol(TokenNames.WHILE);
          case "else": return symbol(TokenNames.ELSE);
          case "new": return symbol(TokenNames.NEW);
          case "extends": return symbol(TokenNames.EXTENDS);
          case "nil": return symbol(TokenNames.NIL);
          default: return symbol(TokenNames.ID, text);
        }
      }

      // Numbers
      if (Character.isDigit(ch)) {
        StringBuilder sb = new StringBuilder();
        sb.append(ch);

        while (true) {
          int next = peek();
          if (next == -1 || !Character.isDigit((char)next)) {
            break;
          }
          sb.append((char)read());
        }

        String text = sb.toString();
        yycolumn = tokenStartColumn + text.length();

        // Check for invalid integer (leading zeros with more digits)
        if (text.length() > 1 && text.charAt(0) == '0') {
          throw new Error("Invalid integer: " + text);
        }

        Integer value = Integer.valueOf(text);
        if (value > MAX_INTEGER_VALUE || value < MIN_INTEGER_VALUE) {
          throw new Error("Integer out of bounds: " + text);
        }
        return symbol(TokenNames.INT, value);
      }

      // Strings
      if (ch == '"') {
        StringBuilder sb = new StringBuilder();
        yycolumn = tokenStartColumn + 1;

        while (true) {
          int next = read();
          if (next == -1) {
            throw new Error("Invalid String: unterminated string");
          }
          char nextChar = (char)next;

          if (nextChar == '"') {
            yycolumn++;
            break;
          }

          if (!Character.isLetter(nextChar)) {
            throw new Error("Invalid String: " + sb.toString() + nextChar);
          }

          sb.append(nextChar);
          yycolumn++;
        }

        return symbol(TokenNames.STRING, sb.toString());
      }

      // Two-character operators
      if (ch == ':') {
        int next = peek();
        if (next == '=') {
          read();
          yycolumn = tokenStartColumn + 2;
          return symbol(TokenNames.ASSIGN);
        }
        throw new Error("Illegal character: " + ch);
      }

      // Single-character operators and punctuation
      yycolumn = tokenStartColumn + 1;

      switch (ch) {
        case '+': return symbol(TokenNames.PLUS);
        case '-': return symbol(TokenNames.MINUS);
        case '*': return symbol(TokenNames.TIMES);
        case '/': return symbol(TokenNames.DIVIDE);
        case '(': return symbol(TokenNames.LPAREN);
        case ')': return symbol(TokenNames.RPAREN);
        case '[': return symbol(TokenNames.LBRACK);
        case ']': return symbol(TokenNames.RBRACK);
        case '{': return symbol(TokenNames.LBRACE);
        case '}': return symbol(TokenNames.RBRACE);
        case ',': return symbol(TokenNames.COMMA);
        case '.': return symbol(TokenNames.DOT);
        case ';': return symbol(TokenNames.SEMICOLON);
        case '=': return symbol(TokenNames.EQ);
        case '<': return symbol(TokenNames.LT);
        case '>': return symbol(TokenNames.GT);
        default:
          throw new Error("Illegal character: " + ch);
      }
    }
  }
}
